---
title: "Doubly Robust Estimation of Causal Effects in R"
description: |
  Some additional details about the website
---

# Computational Simulation {#sim}

- *Goal*: estimate a causal effect when you do not have data from a randomized experiment 

- *Strategy 1*: Re-weighting each observation by the probability of receiving A or B so that the data approximates a randomized experiment 

- *Strategy 2*: Modelling the outcome directly with a linear regression

- *Combining Idea 1 and 2*: To form doubly robust estimator

---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE, 
        fig.align = "center")

library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(knitr)
```

# Setting up data

We assign $X_1$ and $X_2$ as causal variables, and define a true ACE of 10.

```{r setting-up}
simu_observational_data <- function(simu_id = 1, n_obs) {
  X_1    <- rnorm(n_obs)
  X_2    <- rnorm(n_obs)
  XB     <- 0.2*X_1 + 0.2*X_2
  prob_A <- exp(XB) / (1 + exp(XB))
  A      <- rbinom(n_obs, 1, prob_A)
  
  # The causal effect of treatment A is 10
  Y      <- 100 + X_1 + X_2 + 10*A + rnorm(n_obs) 
  
  # summarize variables into a data frame
  data.frame(simu_id = simu_id, n_obs = n_obs, 
             var_1 = X_1, var_2 = X_2, 
             treatment = A, outcome = Y)  
} 
```

## IPW model

```{r}
prop_score_model <- function(data) {
  glm(treatment ~ var_1 + var_2, data = data, family = 'binomial')
}
```

```{r}
prop_score_model_w <- function(data) {
  # OOPS! I forgot var_2
  glm(treatment ~ var_1, data = data, family = 'binomial')
}
```

```{r}
#IPW correct
ipw_estimator <- function(data, model) {
  data %>% 
    mutate(
      prob = predict(model, newdata = data, type = 'response'),
    ) %>% 
    summarise(
      EY0_ipw = mean(outcome*(1 - treatment) / (1 - prob)),
      EY1_ipw = mean(outcome*treatment / prob)
    ) %>% 
    mutate(ipw = EY1_ipw - EY0_ipw)
}
```

```{r}
# IPW wrong
ipw_estimator_w <- function(data, model) {
  data %>% 
    mutate(
      prob = predict(model, newdata = data, type = 'response'),
    ) %>% 
    summarise(
      EYB_ipw = mean(outcome*(1 - treatment) / (1 - prob)),
      EYA_ipw = mean(outcome*treatment / prob)
    ) %>% 
    mutate(ipw_w = EYA_ipw - EYB_ipw)
}
```

## REG model

```{r}
mean_outcome_model <- function(data) {
  glm(outcome ~ treatment + var_1 + var_2, data = data)
}
```

```{r}
mean_outcome_model_w <- function(data) {
  # MISSING var_2??!?!
  glm(outcome ~ var_1 + treatment, data = data)
}
```

```{r}
#REG correct
outcome_model_estimator <- function(data) {
   mean_model <- mean_outcome_model(data) # Compute the model
   summary(mean_model)$coefficients['treatment', ][1] # Coefficient for treatment
}
```

```{r}
# REG wrong
outcome_model_estimator_w <- function(data) {
   mean_model <- mean_outcome_model_w(data)
   summary(mean_model)$coefficients['treatment', ][1]
}
```

## DRE estimator

```{r}
dr_estimator <- function(data, prop_model, mean_model) {
  data %>% 
    mutate(
      prob = predict(prop_model, newdata = data, type = 'response'),
      pred = predict(mean_model, newdata = data, type = 'response'),
      augm = (treatment - prob)*pred
    ) %>% 
    summarise(
      EY0_dr = mean((outcome*(1 - treatment) - augm) / (1 - prob)),
      EY1_dr = mean((outcome*treatment - augm) / prob)
    ) %>% 
    mutate(dre = EY1_dr - EY0_dr)
}
```

```{r, include=FALSE}
naive_estimator <- function(data) {
  data %>% 
    summarise(
      EY0_naive = mean(outcome*(1 - treatment)),
      EY1_naive = mean(outcome*treatment)
    ) %>% 
    mutate(naive_estimator = EY1_naive- EY0_naive)
}
```

```{r, include=FALSE}
n_simu <- 150
n_obs <- 200

nested_df <- 
  purrr::map2_dfr(1:n_simu, rep(n_obs, n_simu), simu_observational_data) %>% 
  group_by(simu_id) %>% 
  nest() %>% 
  mutate(
    prop_model     = map(data, prop_score_model),
    prop_model_w   = map(data, prop_score_model_w),
    mean_model     = map(data, mean_outcome_model),
    mean_model_w   = map(data, mean_outcome_model_w),
    naive_estimate = map(data, naive_estimator),
    model_estimate = map(data, outcome_model_estimator),
    model_estimate_w = map(data, outcome_model_estimator_w),
    ipw_estimate   = map2(data, prop_model, ipw_estimator),
    ipw_estimate_w = map2(data, prop_model_w, ipw_estimator_w),
    dr_estimate    = pmap(list(data, prop_model, mean_model), dr_estimator)
  ) %>% 
  ungroup() %>% 
  unnest(c(naive_estimate, model_estimate, model_estimate_w, ipw_estimate, ipw_estimate_w, dr_estimate))
```

Now, we have five models: IPW (both correct and incorrect), REG (both correct and incorrect), and DRE.

---

# Strategy 1: Inverse Probability Weighting (IPW)
## Intuition Behind it

---

- In an experiment the probability of receiving a treatment are always equal across all units (i.e., 50%)

- In the current case, the probability of receiving the treatment depends on variables that affect the outcome

- If we knew what this probabilities are we could re-weight our sample such that the data would better match a randomized experiment

- In the re-weighting scheme, units that were very likely to receive the treatment are weighted down and units that were very unlikely to receive the treatment are weighted up

- Reminder: propensity score is just a logistic regression of the probability of receiving the treatment

In our example, we proposed the

```{r, eval = FALSE}
prop_score_model <- function(data) {
  glm(treatment ~ var_1 + var_2, data = data, family = 'binomial')
}
```

---

# Strategy 1: IPW estimator

- Similar to a difference of means but weights each observation inversely proportional to its probability of receiving a treatment

$$\widehat {PS}_i=\pi(X_{i})$$

$$\hat{\delta}_{IPW} = \frac{1}{n}\sum_{i=1}^{n}\bigg[\frac{Y_{i}A_{i}}{\color{red}{\pi(X_{i})}} - \frac{Y_{i}(1-A_{i})}{\color{red}{1-\pi(X_{i})}}\bigg]$$

```{r, eval = FALSE}
ipw_estimator <- function(data, model) {
  data %>% 
    mutate(
      prob = predict(model, newdata = data, type = 'response'),
    ) %>% 
    summarise(
      EYB_ipw = mean(outcome*(1 - treatment) / (1 - prob)),
      EYA_ipw = mean(outcome*treatment / prob)
    ) %>% 
    mutate(ipw = EYA_ipw - EYB_ipw)
}
```

---

class: center
# IPW Performance 

```{r, echo = FALSE}
mean_ipw_estimator <- 
  mean(nested_df$ipw)

nested_df %>% 
  ggplot(aes(x = simu_id, y = ipw)) +
  ggtitle(paste('The mean of the ipw estimate (correctly specified) is ', round(mean_ipw_estimator, 2))) + 
  geom_point(color = 'blue') +
  geom_hline(yintercept = 10) +
  theme_bw()
```

---

# IPW could fail

- If the model for A is incorrect, it would cause bias in the IPW, which cause IPW to fail.


```{r, echo = FALSE}
mean_ipw_estimator_w <- 
  mean(nested_df$ipw_w)

nested_df %>% 
  ggplot(aes(x = simu_id, y = ipw_w)) +
  ggtitle(paste('The mean of the ipw estimate (incorrectly specified) is ', round(mean_ipw_estimator_w, 2))) + 
  geom_point(color = 'blue') +
  geom_hline(yintercept = 10) +
  theme_bw()
```


We overestimated the true ACE (which is 10) if we wrongly specified the model form in IPW setting.

---

# Strategy 2: REG estimator (model the outcome)

- Default strategy of data scientist would be to create a linear model

 $$Y =\alpha_0 + \alpha_1 X_1 + \alpha_2 X_2 +\delta A+ \varepsilon$$ 

- Use $\hat{\delta}$ as the estimator of the causal effect

```{r, eval = FALSE}
mean_outcome_model <- function(data) {
  glm(outcome ~ var_1 + var_2 + treatment, data = data)
}
```

```{r, eval = FALSE}
outcome_model_estimator <- function(data) {
   mean_model <- mean_outcome_model(data)
   summary(mean_model)$coefficients['treatment', ][1]
}
```

---

class: center
# Strategy 2: Performance - Simulation

```{r, echo = FALSE}
mean_model_estimator <- 
  mean(nested_df$model_estimate)

nested_df %>% 
  ggplot(aes(x = simu_id, y = model_estimate)) +
  ggtitle(paste('The mean of the REG estimate (correctly specified) is ', round(mean_model_estimator, 2))) + 
  geom_point(color = 'blue') +
  geom_hline(yintercept = 10) +
  theme_bw()
```



---

# REG model could also fail

- If the model for Y is incorrect (as we recalled we left *var_2* out), it would cause bias in the REG outcome model, which cause the model to fail.

```{r}
mean_model_estimator_w <- 
  mean(nested_df$model_estimate_w)

nested_df %>% 
  ggplot(aes(x = simu_id, y = model_estimate_w)) +
  ggtitle(paste('The mean of the REG estimate (incorrectly specified) is ', round(mean_model_estimator_w, 2))) + 
  geom_point(color = 'blue') +
  geom_hline(yintercept = 10) +
  theme_bw()
```

We also overestimated the true ACE (10) if our REG model is mis-specified.


---

# Combining Strategy 1 and 2

--

- If the propensity score model is incorrect, strategy 1 will not work

--

- If the outcome model is incorrect, strategy 2 will not work

--

- If you combine both approaches, you just need either one to work but not both

--

- As a data scientist you have 1 out of 2 chances to get the correct answer

--

- This is called the doubly robustness property

---

# This could also fail but is less likely to do so


---

# Combining Strategy 1 and 2 - Doubly Robust Estimator

$$\hat{\delta}_{DR} = \frac{1}{n}\sum_{i=1}^{n}\bigg[\frac{Y_{i}A_{i} -\color{red}{(A_i-\pi(X_{i}))\mu(X_i, A_i)}}{\pi(X_{i})} - \frac{Y_{i}(1-A_{i}) -\color{red}{(A_i-\pi(X_{i}))\mu(X_i, A_i)}}{1-\pi(X_{i})}\bigg]$$

where $$\mu(X, A) = \hat{\alpha}_0 + \hat{\alpha}_1 X_1 + \hat{\alpha}_2 X_2 +\hat{\delta} A$$

- The term in red is said to *augment* the IPW estimator

- It can be shown that this estimator will consistently estimate $\delta = E[Y(A)]-E[Y(B)]$ as long as either $\pi(X_{i})$ or $\mu(X, A)$ are correct 

---

# Combining Strategy 1 and 2 - Doubly Robust Estimator

```{r, eval = FALSE}
dr_estimator <- function(data, prop_model, mean_model) {
  data %>% 
    mutate(
      prob = predict(prop_model, newdata = data, type = 'response'),
      pred = predict(mean_model, newdata = data, type = 'response'),
      augm = (treatment - prob)*pred
    ) %>% 
    summarise(
      EYB_dr = mean((outcome*(1 - treatment) - augm) / (1 - prob)),
      EYA_dr = mean((outcome*treatment - augm) / prob)
    ) %>% 
    mutate(dre = EYA_dr - EYB_dr)
}
```

---

class: center
# DRE Performance

```{r, echo = FALSE}
mean_dre_estimator <- 
  mean(nested_df$dre)

nested_df %>% 
  ggplot(aes(x = simu_id, y = dre)) +
  ggtitle(paste('The mean of the DRE estimate is ', round(mean_dre_estimator, 2))) + 
  geom_point(color = 'red') +
  geom_hline(yintercept = 10) +
  theme_bw()
```


---

# Doubly Robust Estimator - Propensity Score is Incorrect

```{r}
prop_score_model <- function(data) {
  # OOPS! I forgot var_2
  glm(treatment ~ var_1, data = data, family = 'binomial')
}
```

---

class: center
# Doubly Robust Estimator - Propensity Score is Incorrect

```{r, echo = FALSE}
nested_pe_df <- 
  purrr::map2_dfr(1:n_simu, rep(n_obs, n_simu), simu_observational_data) %>% 
  group_by(simu_id) %>% 
  nest() %>% 
  mutate(
    prop_model     = map(data, prop_score_model),
    mean_model     = map(data, mean_outcome_model),
    naive_estimate = map(data, naive_estimator),
    model_estimate = map(data, outcome_model_estimator),
    ipw_estimate   = map2(data, prop_model, ipw_estimator),
    dr_estimate    = pmap(list(data, prop_model, mean_model), dr_estimator)
  ) %>% 
  ungroup() %>% 
  unnest(c(naive_estimate, model_estimate, ipw_estimate, ipw_estimate, dr_estimate))
```


```{r, echo = FALSE, out.width="60%"}
mean_dre_estimator <- 
  mean(nested_pe_df$dre)

nested_pe_df %>% 
  ggplot(aes(x = simu_id, y = dre)) +
  geom_point(color = 'red') +
  ggtitle(paste('The mean of the DRE estimate is ', round(mean_dre_estimator, 2))) + 
  geom_hline(yintercept = 10) +
  theme_bw()
```

---
# Doubly Robust Estimator - Mean Model is Incorrect

```{r}
mean_outcome_model <- function(data) {
  # HOW COULD I FORGOTTEN var_2??!?! I AM SO DUMB!
  glm(outcome ~ var_1 + treatment, data = data)
}
```

---
<!-- class: center -->
# Doubly Robust Estimator - Mean Model is Incorrect

```{r, echo = FALSE}
nested_om_df <- 
  purrr::map2_dfr(1:n_simu, rep(n_obs, n_simu), simu_observational_data) %>% 
  group_by(simu_id) %>% 
  nest() %>% 
  mutate(
    prop_model     = map(data, prop_score_model),
    mean_model     = map(data, mean_outcome_model),
    naive_estimate = map(data, naive_estimator),
    model_estimate = map(data, outcome_model_estimator),
    ipw_estimate   = map2(data, prop_model, ipw_estimator),
    dr_estimate    = pmap(list(data, prop_model, mean_model), dr_estimator)
  ) %>% 
  ungroup() %>% 
  unnest(c(naive_estimate, model_estimate, ipw_estimate, ipw_estimate, dr_estimate))
```

```{r, echo = FALSE, out.width="60%"}
mean_dre_estimator <- 
  mean(nested_om_df$dre)

nested_om_df %>% 
  ggplot(aes(x = simu_id, y = dre)) +
  geom_point(color = 'red') +
  ggtitle(paste('The mean of the DRE estimate is ', round(mean_dre_estimator, 2))) + 
  geom_hline(yintercept = 10) +
  theme_bw()
```

---
# Conclusion

- If you have non randomized data you cannot simply calculate the difference in means between $A$
 and $B$ to estimate the causal effect
 
- You can use the IPW estimator based on a logistic regression of the probability of receiving the treatment

- You can model the outcome based on a linear regression with the confounding variables as well as $A$

- Or you can use the doubly robust estimator which will work as long as either the logistic or the linear regression are correct, but not both

---
# References

- Lunceford, Jared K., and Marie Davidian. "Stratification and weighting via the propensity score in estimation of causal treatment effects: a comparative study." Statistics in medicine 23.19 (2004): 2937-2960.

